<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>duckdb-wasm-local example</title>
    <link rel="stylesheet" type="text/css" href="css/leaflet.css" />
    <style type="text/css">
     #feedback {
	     margin-bottom: 1rem;
	     font-style:italic;
     }

     .grid-view {
	     display: grid;
	     grid-template-columns:1fr 1fr;
	     gap: 50px 10px;
     }
     
     #results {
	     max-height: 80vh;
	     overflow:scroll;
     }

     #map {
	     width: 100%;
	     height: 100vh;
     }
     
    </style>
  </head>
  <body>
      <div id="feedback">Loading DuckDB</div>
      <div class="grid-view">
	  <div id="map"></div>	  
	  <div>
	      <input type="text" id="q" value="" placeholder="" />
	      <select id="locality"></select>
	      <select id="neighbourhood"></select>	      
	      <button id="submit" type="submit" disabled="disabled">Search</button>
	      <div id="results">
	      </div>
	  </div>
      </div>

      <script type="text/javascript" src="javascript/leaflet.js"></script>
      <script type="text/javascript" src="javascript/protomaps-leaflet.js"></script>      
      <script type="text/javascript" src="javascript/init.js"></script>
      
      <script type="module">
       // import * as duckdbduckdbWasm from "https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.1-dev106.0/+esm";
       import * as duckdbduckdbWasm from "./duckdb-wasm-local/duckdb-wasm.js"
       
       window.duckdbduckdbWasm = duckdbduckdbWasm;
       
       var fb = document.getElementById("feedback");
       
       getDb().then(async (db) => {

	   // en-CA is important in order to get YYYY-MM-dd formatting. Go, Canada!
	   const dt_formatter = new Intl.DateTimeFormat('en-CA', {
	       year: 'numeric',
	       month: '2-digit',
	       day: '2-digit',
	       timeZone: 'America/Los_Angeles',		    
	   });	   

	   const num_formatter = new Intl.NumberFormat();
	   
	   fb.innerText = "Connecting to database";
	   
           const conn = await db.connect();

	   fb.innerText = "Setting up map";

	   var map;
	   var base_layer;
	   var markers_layer;
	   
	   // Apparently ST_Extent_Agg is not available in duckdb-wasm
	   // await conn.query("LOAD spatial");
	   // const extent_r = await conn.query("SELECT ST_Extent_Agg(geom) FROM (SELECT ST_GeomFromWKB(geom) FROM read_parquet('http://localhost:8080/data/sfba.parquet')) AS _(geom)");

	   /*

	   Error: Catalog Error: Scalar Function with name st_extent_agg does not exist!
	   Did you mean "ST_Extent"?
	   LINE 1: SELECT ST_Extent_Agg(geom) FROM (SELECT ST_Geo...
           */
	   
	   var min_x;
	   var min_y;
	   var max_x;
	   var max_y;
	   
	   try {
	       const minx_r = await conn.query("SELECT longitude FROM read_parquet('http://localhost:8080/data/sfba.parquet') ORDER by longitude ASC LIMIT 1");
	       const miny_r = await conn.query("SELECT latitude FROM read_parquet('http://localhost:8080/data/sfba.parquet') ORDER by latitude ASC LIMIT 1");
	       const maxx_r = await conn.query("SELECT longitude FROM read_parquet('http://localhost:8080/data/sfba.parquet') ORDER by longitude DESC LIMIT 1");
	       const maxy_r = await conn.query("SELECT latitude FROM read_parquet('http://localhost:8080/data/sfba.parquet') ORDER by latitude DESC LIMIT 1");	   
	       
	       min_x = minx_r.toArray()[0].longitude;
	       min_y = miny_r.toArray()[0].latitude;
	       max_x = maxx_r.toArray()[0].longitude;
	       max_y = maxy_r.toArray()[0].latitude;
	       
	   } catch(err) {
	       fb.innerText = "Failed to derive extent, " + err;
	       console.error(err);	       
	       return;
	   }

	   var bounds = [
	       [ min_y, min_x ],
	       [ max_y, max_x ],
	   ];

	   map = L.map('map');
	   map.fitBounds(bounds);

	   /*
	   base_layer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
	       maxZoom: 19,
	   });
	   */
	   
	   base_layer = protomapsL.leafletLayer({
	       url:'http://localhost:8080/pmtiles/sfba.pmtiles',
	       // go run main.go serve /usr/local/whosonfirst/whosonfirst-external-duckdb/www/pmtiles --port=8081 --cors="*"
	       // url:'http://localhost:8081/sfba/{z}/{x}/{y}.mvt',	       
	       theme:"white"
	   });
	   
	   base_layer.addTo(map);

	   // 

	   fb.innerText = "Setting up localities";

	   // Note: It is not really useful to use SELECT DISTINCT(locality) FROM read_parquet('sfba.parquet') ORDER BY locality ASC;
	   // because it just returns garbage and gibberish.
	   
	   // Wut: The first query triggers the following error:
	   // DuckDB: Error: Binder Error: Cannot extract field 'locality_id' from expression "array_extract(CAST(json_extract(wof:hierarchies, '$') AS VARCHAR), CAST(0 AS BIGINT))" because it is not a struct or a union
	   // const locality_results = await conn.query("SELECT DISTINCT(JSON(\"wof:hierarchies\")[0].locality_id) FROM read_parquet('http://localhost:8080/data/sfba.parquet')");

	   // This however works...
	   const locality_results = await conn.query("SELECT DISTINCT(JSON_EXTRACT_STRING(\"wof:hierarchies\", '$[0].locality_id')) AS locality_id FROM read_parquet('http://localhost:8080/data/sfba.parquet')");
	   
	   var locality_names = {};
	   var locality_count = 0;

	   var draw_localities = function() {
	       // console.log("DRAW", locality_names);

	       var lookup = {};
	       var names = [];

	       for (var id in locality_names){

		   var name = locality_names[id];

		   if(names.indexOf(names) == -1){
		       names.push(name);
		   }
		       
		   var ids = lookup[name];

		   if (!ids){
		       ids = [];
		   }

		   ids.push(id);
		   lookup[name] = ids;
	       }

	       names.sort()

	       var sel = document.getElementById("locality");

	       var opt = document.createElement("option");
	       opt.setAttribute("value", "-1");
	       opt.appendChild(document.createTextNode(""));
	       
	       sel.appendChild(opt);

	       for (var i in names){

		   var name = names[i];
		   var ids = lookup[name];

		   for (var j in ids){

		       var id = ids[j];

		       var opt = document.createElement("option");
		       opt.setAttribute("value", id);
		       opt.appendChild(document.createTextNode(name));

		       sel.appendChild(opt);
		   }
	       }

	       var neighbourhoods = async function(locality_id) {

		   var sel = document.getElementById("neighbourhood");
		   sel.innerHTML = "";
		   
		   if (locality_id == -1){
		       return;
		   }

		   var neighbourhood_names = {};
		   var neighbourhood_count = 0;

		   var draw_neighbourhoods = function() {

		       var lookup = {};
		       var names = [];
		       
		       for (var id in neighbourhood_names){

			   var name = neighbourhood_names[id];
			   
			   if(names.indexOf(names) == -1){
			       names.push(name);
			   }
			   
			   var ids = lookup[name];
			   
			   if (!ids){
			       ids = [];
			   }
			   
			   ids.push(id);
			   lookup[name] = ids;
		       }
		       
		       names.sort()
		       
		       var sel = document.getElementById("neighbourhood");
		       
		       var opt = document.createElement("option");
		       opt.setAttribute("value", "-1");
		       opt.appendChild(document.createTextNode(""));
		       
		       sel.appendChild(opt);
		       
		       for (var i in names){
			   
			   var name = names[i];
			   var ids = lookup[name];
			   
			   for (var j in ids){
			       
			       var id = ids[j];
			       
			       var opt = document.createElement("option");
			       opt.setAttribute("value", id);
			       opt.appendChild(document.createTextNode(name));
			       
			       sel.appendChild(opt);
			   }
		       }
		   };
		   
		   const neighbourhood_results = await conn.query("SELECT DISTINCT(JSON_EXTRACT_STRING(\"wof:hierarchies\", '$[0].neighbourhood_id')) AS neighbourhood_id FROM read_parquet('http://localhost:8080/data/sfba.parquet') WHERE JSON_EXTRACT(\"wof:hierarchies\", '$[0].locality_id') = '" + locality_id + "'");

		   for (const row of neighbourhood_results) {

		       if (! row.neighbourhood_id){
			   continue;
		       }
		       
		       neighbourhood_count += 1;

		       console.log("WTF", row.neighbourhood_id)
		       const neighbourhood_url = "https://data.whosonfirst.org/geojson/" + row.neighbourhood_id;
		       console.log("Fetch", neighbourhood_url);
		       // continue;
		       
		       fetch(neighbourhood_url)
			   .then((response) => response.json())
			   .then((data) => {

			       const id = data.properties["wof:id"];
			       const name = data.properties["wof:name"];

			       console.log("WUT", id, name);
			       neighbourhood_names[id] = name;
			       
			       neighbourhood_count -=1;
			       
			       if (neighbourhood_count == 0){
				   draw_neighbourhoods();
			       }
			       
			   }).catch((err) => {
			       
			       neighbourhood_count -=1;
			       
			       console.log("SAD", err, neighbourhood_count);
			       
			       if (neighbourhood_count == 0){
				   draw_neighbourhoods();			   
			       }
			       
			   });
		   }
		   
	       };
	       
	       sel.onchange = function(e){
		   var el = e.target;
		   var locality_id = el.value;

		   neighbourhoods(locality_id);
		   return false;
	       };
	   };
	   
	   for (const row of locality_results) {
	       locality_count += 1;

	       const locality_url = "https://data.whosonfirst.org/geojson/" + row.locality_id;
	       console.log("Fetch", locality_url);
	       
	       fetch(locality_url)
		   .then((response) => response.json())
		   .then((data) => {

		       const id = data.properties["wof:id"];
		       const name = data.properties["wof:name"];

		       locality_names[id] = name;

		       locality_count -=1;

		       if (locality_count == 0){
			   draw_localities();
		       }
		       
		   }).catch((err) => {

		       locality_count -=1;

		       console.log("SAD", err, locality_count);
		       
		       if (locality_count == 0){
			   draw_localities();			   
		       }
		       
		   });
	   }
	   
	   //
	   
	   fb.innerText = "Setting up search table";
	   
	   await conn.query("CREATE TABLE search AS SELECT fsq_place_id AS id, name, address, JSON_EXTRACT(\"wof:hierarchies\", '$[0].locality_id') AS locality_id, JSON_EXTRACT(\"wof:hierarchies\", '$[0].neighbourhood_id') AS neighbourhood_id FROM read_parquet('http://localhost:8080/data/sfba.parquet')");

	   fb.innerText = "Setting up database PRAGMA";	   
	   
	   await conn.query("PRAGMA create_fts_index('search', 'id', 'name', 'address', 'locality_id', 'neighbourhood_id')");
	   
	   fb.innerText = "Ready to search";

	   var input = document.getElementById("q");
	   var locality = document.getElementById("locality");	   
	   
	   var b = document.getElementById("submit");
	   b.removeAttribute("disabled");
	   
	   b.onclick = async function(e){

	       if (markers_layer){
		   map.removeLayer(markers_layer);
	       }
	       
	       var q = input.value;
	       var locality_id = parseInt(locality.value);
	       
	       var html_results = document.getElementById("results");
	       html_results.innerText = "";
	       
	       fb.innerText = "Performing search";

	       var where = [
		   "score IS NOT NULL",
	       ];

	       if ((locality_id != NaN) && (locality_id != -1)){
		   where.push("locality_id = " + locality_id);
	       }
		       
	       const str_where = where.join(" AND ");

	       const ids_results = await conn.query("SELECT fts_main_search.match_bm25(id, '" + q + "') AS score, id FROM search WHERE " + str_where + " ORDER BY score DESC");

	       var ids_count = ids_results.toArray().length;

	       if (! ids_count){
		   fb.innerText = "No results found. Ready to search";
		   return false;
	       }

	       var ids_list = [];
	       
	       for (const row of ids_results) {
		   ids_list.push("'" + row.id + "'");
               }

	       const search_results = await conn.query("SELECT fsq_place_id AS id, name, address, locality, JSON(fsq_category_labels) AS categories, latitude, longitude FROM read_parquet('http://localhost:8080/data/sfba.parquet') WHERE fsq_place_id IN ( " + ids_list.join(",") + ") AND date_closed IS NULL");

	       var count_results = search_results.toArray().length;
	       
	       var html_list = document.createElement("ul");

	       switch (count_results) {
		   case 1:
		       fb.innerText = "Compiling only result";
		       break;
		   default:
		       fb.innerText = "Compiling " + count_results + " results";
		       break;
	       }

	       var features = [];
	       
	       for (const row of search_results) {

		   var props = {
		       'id': row.id,
		       'name': row.name,
		       'address': row.address,
		       'locality': row.locality,
		       'categories': JSON.parse(row.categories),
		   };
		   
		   var geom = {
		       'type': 'Point',
		       'coordinates': [ row.longitude, row.latitude ],
		   };

		   var f = {
		       'type': 'Feature',
		       'geometry': geom,
		       'properties': props,
		   }

		   features.push(f);

		   var item = document.createElement("li");

		   item.appendChild(document.createTextNode(row.name));
		   item.appendChild(document.createElement("br"));
		   item.appendChild(document.createTextNode(row.address + ", " + row.locality));
		   item.appendChild(document.createElement("br"));

		   if (row.categories){
		       item.appendChild(document.createTextNode(row.categories));
		   }
		   
		   html_list.appendChild(item);
               }

	       var markers_style = {
		   radius: 8,
		   fillColor: "#ff7800",
		   color: "#000",
		   weight: 1,
		   opacity: 1,
		   fillOpacity: 0.8
	       };

	       var markers_opts = {
		   pointToLayer: function (feature, latlng) {
		       return L.circleMarker(latlng, markers_style);
		   }
	       };
	       
	       markers_layer = L.geoJSON(features, markers_opts);
	       markers_layer.addTo(map);
	       
	       
	       html_results.appendChild(html_list);
	       
	       switch (count_results){
		   case 1:
		       fb.innerText = "Ready to search again.";
		       break;
		   default:		       
		       fb.innerText = num_formatter.format(count_results) + " results. Ready to search again.";
		       break;
	       }
	       
	       return false;
	   };
	   
       }).catch((err) => {
	   var fb = document.getElementById("feedback");
	   fb.innerText = "Failed to configure DuckDB: " + err;
	   console.error("Failed to configure DuckDB", err);
       });
       
    </script>
  </body>
</html>
